%!TEX root = /Users/jp/Thesis/Thesis.tex
\chapter{Background} % (fold)
\label{cha:background}

\section{Definitions} % (fold)
\label{sec:definitions}

Before getting into deeper details about the project, it is important to clearly define some terms that will be used throughout this report.

\subsection{Web Service} % (fold)
\label{sub:web_service_def}

We think of Web Services in an abstract sense, as providers of content in response to a request, over the Internet. We assume that they can answer a precise query based on a set of defined conditions, and that they will return an ordered set of answers, the order being either based on a criteria provided by the user or by a relevancy score internal to the service. We can further take in consideration that the service has some performance rating, depending on the delay in which it returns the results as well as the quantity and quality of the results. Furthermore, we expect most web services to support some kind of pagination protocol in order to retrieve subsets of the data sequentially. Another important aspect of the services is that they might be subject to a monetary cost, or a limit in the querying rate, based on a daily period or otherwise.

For our purpose, the technology used for the transport and querying interface doesn't matter, be it SOAP, REST, Protobuffers or another binary or text encoding protocol. We assume that an adapter will be developed for each type of Web Service in order to use it.

% subsection web_service_def (end)

\subsection{Domain} % (fold)
\label{sub:domain_def}

A domain is a field of research as provided by one or more search engines. It could be, for example, international events, health professionals, countries information. In a query made by a user, a domain is characterized by the following parts:

\begin{itemize}

  \item One or more objects: While a domain represent an abstract entity, these are the concrete apparitions of the domain within the query. They may correspond directly to the name of the domain (eg. Give me a warm \emph{country}\ with cheap flights on the weekend of the first of may) or not (eg. Give me a \emph{conference}\ about computer science where I can also go to the opera, where conference is an object of the domain ``Event''). Additionally, more than one objects might refer to the same domain, in which case they need to be taken together.

  \item Conditions: Some conditions are given explicitly (eg. Give me a conference \emph{about computer science}.), while others can be deducted from the objects (\emph{conference}\ being a type of event). In general, conditions restrict the field of search that will be sent to the service. Some conditions are objective while others make use of subjective judgements (eg. \emph{warm}\ country).

  \item Ordering: Making the ranking and ordering according to some relevance score is an integral part of this project, and thus the ordering must be extracted and taken into account while answering a user's query. Again, some conditions can be subjective (the \emph{best}\ doctor in the region) while other elements can be taken both as a condition and as an implicit ordering ( \emph{cheap}\ flights will expose a cutoff in addition to the ordering by ascending price).

  \item One or more joins with other domains: at the core of this project is the presence of multiple domains within one query. These different domains must be joined in some way. These joins can be explicit, or inferred through a chain of relationships (an event is an city, that city is in a country) as expressed through a semantic network.

\end{itemize}


% subsection domain_def (end)

% section definitions (end)


\section{SeCo -- Search Computing} % (fold)
\label{sec:seco}

SeCo is the platform which aims to push the limits of the field of multi-domain queries by formalizing theoretical aspects as well as providing a software engineering point of view, enabling the construction of a usable search engine that will answer arbitrary queries.

\subsection{General Architecture} % (fold)
\label{sub:general_architecture}

SeCo is divided in different higher-level components orchestrated in a service-oriented manner. The main components are the query analysis, the query-to-domain mapper, the query planner, the query engine and the results transformation. Two frameworks named the service and domain frameworks are also added as intelligent repositories.

A query sent from the user first passes through the query analysis and the query-to-domain mapper, where the different domains and properties are extracted from the natural language query. It then goes to the query planner, which creates an execution plan taking into accounts the different costs associated to executing the query, in order to create the most efficient execution. The different subqueries are then sent to the domain and service frameworks, which take care of calling the external services through a Web or messaging interface. The results are then collected, and, according to the plan, merged back together. The final results are then transformed before being sent back to the user.

% subsection general_architecture (end)

\subsection{Query Analysis} % (fold)
\label{sub:query_analysis}

In order for a user to query the database of information and knowledge available in SeCo, he or she first needs to input it, whether by a Web interface, or by making a direct call to the programming interface of the system. The type of query the user gives can vary a lot, and it is for the system to try and understand the meaning of the question. In general, the contract of this component is to take the input as given by the user, try to separate it according to the sub-queries that can be found and send those down the line to the query planner.

% subsection query_analysis (end)

\subsection{Query to Domain Mapper} % (fold)
\label{sub:query_to_domain_mapper}

While the set of sub-queries is a first step towards actually executing the query, it still represents an abstract, human request that might or might not correspond to the the services available in the system. The Query to Domain Mapper will take each sub-query in turn, and corresponding to the vocabulary used and the elements in the query, will try to associate a domain as stored in the domain framework. It will send this augmented request to the next component, the query planner.

% subsection query_to_domain_mapper (end)

\subsection{Query Planner} % (fold)
\label{sub:query_planner}

The Query Planner's task is to take the set of high-level queries to different domains and turn it into an executable plan. This involves planning the fetching of data to web services, taking into account the frequency and quantity of data that will be required, and the merge operations that will be done, all in order to minimize the time and memory spent, as well as any costs related to the user of the web services.

This plan is now ready to be executed by the query engine as it contains precise instructions on what to execute and in which order. It is comparable to having taken a declarative program as input and obtaining an imperative program that can be run directly.

% subsection query_planner (end)

\subsection{Query Engine} % (fold)
\label{sub:query_engine}
This component takes the low-level plan from the query planner and executes the different service calls in parallel, merging and ordering when required. It will return the final results of the query in a pure and internal format as they become available, sending them to the results transformation component for their final processing.

Care must be taken in accord to the availability and performance of the invoked services. Since there is an heavy reliance on external components, failures or low performance problems will be common and will have to be considered while fetching the results.
% subsection query_engine (end)

\subsection{Results Transformation} % (fold)
\label{sub:results_transformation}
This component's role is to take the results as given by the Query Engine, and to transform and format them in the way that was required by the client. It implements features such as paging, XML or XHTML output.
% subsection results_transformation (end)

% section seco (end)

\section{Sources of input data} % (fold)
\label{sec:sources_of_input_data}

In order to 
% section sources_of_input_data (end)

\section{Query Analysis} % (fold)
\label{sec:query_analysis}

\subsection{Natural Language Processing} % (fold)
\label{sub:natural_language_processing}

% subsection natural_language_processing (end)

\section{Parse Trees} % (fold)
\label{sec:parse_trees}

% section parse_trees (end)

% section query_analysis (end)

\section{Use of Query Analysis within SeCo} % (fold)
\label{sec:use_of_query_analysis_within_seco}

% section use_of_query_analysis_within_seco (end)

\section{Originality} % (fold)
\label{sec:originality}

% section originality (end)

% chapter background (end)
